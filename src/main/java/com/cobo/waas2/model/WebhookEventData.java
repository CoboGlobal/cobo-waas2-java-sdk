/*
 * Cobo Wallet as a Service 2.0
 *
 * Contact: help@cobo.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.cobo.waas2.model;

import java.util.Objects;
import com.cobo.waas2.model.AcquiringType;
import com.cobo.waas2.model.AddressesEventData;
import com.cobo.waas2.model.AddressesEventDataAllOfAddresses;
import com.cobo.waas2.model.Balance;
import com.cobo.waas2.model.BalanceUpdateInfoEventData;
import com.cobo.waas2.model.ChainInfo;
import com.cobo.waas2.model.ChainsEventData;
import com.cobo.waas2.model.MPCVaultEventData;
import com.cobo.waas2.model.PaymentAddressUpdateEventData;
import com.cobo.waas2.model.PaymentOrderEventData;
import com.cobo.waas2.model.PaymentRefundEventData;
import com.cobo.waas2.model.PaymentSettlementEvent;
import com.cobo.waas2.model.PaymentTransaction;
import com.cobo.waas2.model.PaymentTransactionEventData;
import com.cobo.waas2.model.RefundType;
import com.cobo.waas2.model.RootPubkey;
import com.cobo.waas2.model.SettleStatus;
import com.cobo.waas2.model.SettlementDetail;
import com.cobo.waas2.model.SourceGroup;
import com.cobo.waas2.model.SuspendedTokenEventData;
import com.cobo.waas2.model.SuspendedTokenOperationType;
import com.cobo.waas2.model.TSSRequestWebhookEventData;
import com.cobo.waas2.model.TokenInfo;
import com.cobo.waas2.model.TokenListingEventData;
import com.cobo.waas2.model.TokensEventData;
import com.cobo.waas2.model.TransactionBlockInfo;
import com.cobo.waas2.model.TransactionDestination;
import com.cobo.waas2.model.TransactionFee;
import com.cobo.waas2.model.TransactionFuelingInfo;
import com.cobo.waas2.model.TransactionInitiatorType;
import com.cobo.waas2.model.TransactionRawTxInfo;
import com.cobo.waas2.model.TransactionReplacement;
import com.cobo.waas2.model.TransactionResult;
import com.cobo.waas2.model.TransactionSource;
import com.cobo.waas2.model.TransactionStatus;
import com.cobo.waas2.model.TransactionSubStatus;
import com.cobo.waas2.model.TransactionType;
import com.cobo.waas2.model.TransactionWebhookEventData;
import com.cobo.waas2.model.WalletInfo;
import com.cobo.waas2.model.WalletInfoEventData;
import com.cobo.waas2.model.WalletSubtype;
import com.cobo.waas2.model.WalletType;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.UUID;



import java.io.IOException;
import java.lang.reflect.Type;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.JsonPrimitive;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonArray;
import com.google.gson.JsonParseException;

import com.cobo.waas2.JSON;

@javax.annotation.Generated(
    value = "org.openapitools.codegen.languages.JavaClientCodegen", 
    comments = "Generator version: 7.6.0"
)
public class WebhookEventData extends AbstractOpenApiSchema {
    private static final Logger log = Logger.getLogger(WebhookEventData.class.getName());

    public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
        @SuppressWarnings("unchecked")
        @Override
        public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
            if (!WebhookEventData.class.isAssignableFrom(type.getRawType())) {
                return null; // this class only serializes 'WebhookEventData' and its subtypes
            }
            final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
            final TypeAdapter<TransactionWebhookEventData> adapterTransactionWebhookEventData = gson.getDelegateAdapter(this, TypeToken.get(TransactionWebhookEventData.class));
            final TypeAdapter<TSSRequestWebhookEventData> adapterTSSRequestWebhookEventData = gson.getDelegateAdapter(this, TypeToken.get(TSSRequestWebhookEventData.class));
            final TypeAdapter<AddressesEventData> adapterAddressesEventData = gson.getDelegateAdapter(this, TypeToken.get(AddressesEventData.class));
            final TypeAdapter<WalletInfoEventData> adapterWalletInfoEventData = gson.getDelegateAdapter(this, TypeToken.get(WalletInfoEventData.class));
            final TypeAdapter<MPCVaultEventData> adapterMPCVaultEventData = gson.getDelegateAdapter(this, TypeToken.get(MPCVaultEventData.class));
            final TypeAdapter<ChainsEventData> adapterChainsEventData = gson.getDelegateAdapter(this, TypeToken.get(ChainsEventData.class));
            final TypeAdapter<TokensEventData> adapterTokensEventData = gson.getDelegateAdapter(this, TypeToken.get(TokensEventData.class));
            final TypeAdapter<TokenListingEventData> adapterTokenListingEventData = gson.getDelegateAdapter(this, TypeToken.get(TokenListingEventData.class));
            final TypeAdapter<BalanceUpdateInfoEventData> adapterBalanceUpdateInfoEventData = gson.getDelegateAdapter(this, TypeToken.get(BalanceUpdateInfoEventData.class));
            final TypeAdapter<SuspendedTokenEventData> adapterSuspendedTokenEventData = gson.getDelegateAdapter(this, TypeToken.get(SuspendedTokenEventData.class));
            final TypeAdapter<PaymentOrderEventData> adapterPaymentOrderEventData = gson.getDelegateAdapter(this, TypeToken.get(PaymentOrderEventData.class));
            final TypeAdapter<PaymentRefundEventData> adapterPaymentRefundEventData = gson.getDelegateAdapter(this, TypeToken.get(PaymentRefundEventData.class));
            final TypeAdapter<PaymentSettlementEvent> adapterPaymentSettlementEvent = gson.getDelegateAdapter(this, TypeToken.get(PaymentSettlementEvent.class));
            final TypeAdapter<PaymentTransactionEventData> adapterPaymentTransactionEventData = gson.getDelegateAdapter(this, TypeToken.get(PaymentTransactionEventData.class));
            final TypeAdapter<PaymentAddressUpdateEventData> adapterPaymentAddressUpdateEventData = gson.getDelegateAdapter(this, TypeToken.get(PaymentAddressUpdateEventData.class));

            return (TypeAdapter<T>) new TypeAdapter<WebhookEventData>() {
                @Override
                public void write(JsonWriter out, WebhookEventData value) throws IOException {
                    if (value == null || value.getActualInstance() == null) {
                        elementAdapter.write(out, null);
                        return;
                    }

                    // check if the actual instance is of the type `TransactionWebhookEventData`
                    if (value.getActualInstance() instanceof TransactionWebhookEventData) {
                        JsonElement element = adapterTransactionWebhookEventData.toJsonTree((TransactionWebhookEventData)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `TSSRequestWebhookEventData`
                    if (value.getActualInstance() instanceof TSSRequestWebhookEventData) {
                        JsonElement element = adapterTSSRequestWebhookEventData.toJsonTree((TSSRequestWebhookEventData)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `AddressesEventData`
                    if (value.getActualInstance() instanceof AddressesEventData) {
                        JsonElement element = adapterAddressesEventData.toJsonTree((AddressesEventData)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `WalletInfoEventData`
                    if (value.getActualInstance() instanceof WalletInfoEventData) {
                        JsonElement element = adapterWalletInfoEventData.toJsonTree((WalletInfoEventData)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `MPCVaultEventData`
                    if (value.getActualInstance() instanceof MPCVaultEventData) {
                        JsonElement element = adapterMPCVaultEventData.toJsonTree((MPCVaultEventData)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `ChainsEventData`
                    if (value.getActualInstance() instanceof ChainsEventData) {
                        JsonElement element = adapterChainsEventData.toJsonTree((ChainsEventData)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `TokensEventData`
                    if (value.getActualInstance() instanceof TokensEventData) {
                        JsonElement element = adapterTokensEventData.toJsonTree((TokensEventData)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `TokenListingEventData`
                    if (value.getActualInstance() instanceof TokenListingEventData) {
                        JsonElement element = adapterTokenListingEventData.toJsonTree((TokenListingEventData)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `BalanceUpdateInfoEventData`
                    if (value.getActualInstance() instanceof BalanceUpdateInfoEventData) {
                        JsonElement element = adapterBalanceUpdateInfoEventData.toJsonTree((BalanceUpdateInfoEventData)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `SuspendedTokenEventData`
                    if (value.getActualInstance() instanceof SuspendedTokenEventData) {
                        JsonElement element = adapterSuspendedTokenEventData.toJsonTree((SuspendedTokenEventData)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `PaymentOrderEventData`
                    if (value.getActualInstance() instanceof PaymentOrderEventData) {
                        JsonElement element = adapterPaymentOrderEventData.toJsonTree((PaymentOrderEventData)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `PaymentRefundEventData`
                    if (value.getActualInstance() instanceof PaymentRefundEventData) {
                        JsonElement element = adapterPaymentRefundEventData.toJsonTree((PaymentRefundEventData)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `PaymentSettlementEvent`
                    if (value.getActualInstance() instanceof PaymentSettlementEvent) {
                        JsonElement element = adapterPaymentSettlementEvent.toJsonTree((PaymentSettlementEvent)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `PaymentTransactionEventData`
                    if (value.getActualInstance() instanceof PaymentTransactionEventData) {
                        JsonElement element = adapterPaymentTransactionEventData.toJsonTree((PaymentTransactionEventData)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `PaymentAddressUpdateEventData`
                    if (value.getActualInstance() instanceof PaymentAddressUpdateEventData) {
                        JsonElement element = adapterPaymentAddressUpdateEventData.toJsonTree((PaymentAddressUpdateEventData)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    throw new IOException("Failed to serialize as the type doesn't match oneOf schemas: AddressesEventData, BalanceUpdateInfoEventData, ChainsEventData, MPCVaultEventData, PaymentAddressUpdateEventData, PaymentOrderEventData, PaymentRefundEventData, PaymentSettlementEvent, PaymentTransactionEventData, SuspendedTokenEventData, TSSRequestWebhookEventData, TokenListingEventData, TokensEventData, TransactionWebhookEventData, WalletInfoEventData");
                }

                @Override
                public WebhookEventData read(JsonReader in) throws IOException {
                    Object deserialized = null;
                    JsonElement jsonElement = elementAdapter.read(in);

                    JsonObject jsonObject = jsonElement.getAsJsonObject();

                    // use discriminator value for faster oneOf lookup
                    WebhookEventData newWebhookEventData = new WebhookEventData();
                    if (jsonObject.get("data_type") == null) {
                        log.log(Level.WARNING, "Failed to lookup discriminator value for WebhookEventData as `data_type` was not found in the payload or the payload is empty.");
                    } else  {
                        // look up the discriminator value in the field `data_type`
                        switch (jsonObject.get("data_type").getAsString()) {
                            case "Addresses":
                                deserialized = adapterAddressesEventData.fromJsonTree(jsonObject);
                                newWebhookEventData.setActualInstance(deserialized);
                                return newWebhookEventData;
                            case "BalanceUpdateInfo":
                                deserialized = adapterBalanceUpdateInfoEventData.fromJsonTree(jsonObject);
                                newWebhookEventData.setActualInstance(deserialized);
                                return newWebhookEventData;
                            case "Chains":
                                deserialized = adapterChainsEventData.fromJsonTree(jsonObject);
                                newWebhookEventData.setActualInstance(deserialized);
                                return newWebhookEventData;
                            case "MPCVault":
                                deserialized = adapterMPCVaultEventData.fromJsonTree(jsonObject);
                                newWebhookEventData.setActualInstance(deserialized);
                                return newWebhookEventData;
                            case "PaymentAddressUpdate":
                                deserialized = adapterPaymentAddressUpdateEventData.fromJsonTree(jsonObject);
                                newWebhookEventData.setActualInstance(deserialized);
                                return newWebhookEventData;
                            case "PaymentOrder":
                                deserialized = adapterPaymentOrderEventData.fromJsonTree(jsonObject);
                                newWebhookEventData.setActualInstance(deserialized);
                                return newWebhookEventData;
                            case "PaymentRefund":
                                deserialized = adapterPaymentRefundEventData.fromJsonTree(jsonObject);
                                newWebhookEventData.setActualInstance(deserialized);
                                return newWebhookEventData;
                            case "PaymentSettlement":
                                deserialized = adapterPaymentSettlementEvent.fromJsonTree(jsonObject);
                                newWebhookEventData.setActualInstance(deserialized);
                                return newWebhookEventData;
                            case "PaymentTransaction":
                                deserialized = adapterPaymentTransactionEventData.fromJsonTree(jsonObject);
                                newWebhookEventData.setActualInstance(deserialized);
                                return newWebhookEventData;
                            case "SuspendedToken":
                                deserialized = adapterSuspendedTokenEventData.fromJsonTree(jsonObject);
                                newWebhookEventData.setActualInstance(deserialized);
                                return newWebhookEventData;
                            case "TSSRequest":
                                deserialized = adapterTSSRequestWebhookEventData.fromJsonTree(jsonObject);
                                newWebhookEventData.setActualInstance(deserialized);
                                return newWebhookEventData;
                            case "TokenListing":
                                deserialized = adapterTokenListingEventData.fromJsonTree(jsonObject);
                                newWebhookEventData.setActualInstance(deserialized);
                                return newWebhookEventData;
                            case "Tokens":
                                deserialized = adapterTokensEventData.fromJsonTree(jsonObject);
                                newWebhookEventData.setActualInstance(deserialized);
                                return newWebhookEventData;
                            case "Transaction":
                                deserialized = adapterTransactionWebhookEventData.fromJsonTree(jsonObject);
                                newWebhookEventData.setActualInstance(deserialized);
                                return newWebhookEventData;
                            case "WalletInfo":
                                deserialized = adapterWalletInfoEventData.fromJsonTree(jsonObject);
                                newWebhookEventData.setActualInstance(deserialized);
                                return newWebhookEventData;
                            case "AddressesEventData":
                                deserialized = adapterAddressesEventData.fromJsonTree(jsonObject);
                                newWebhookEventData.setActualInstance(deserialized);
                                return newWebhookEventData;
                            case "BalanceUpdateInfoEventData":
                                deserialized = adapterBalanceUpdateInfoEventData.fromJsonTree(jsonObject);
                                newWebhookEventData.setActualInstance(deserialized);
                                return newWebhookEventData;
                            case "ChainsEventData":
                                deserialized = adapterChainsEventData.fromJsonTree(jsonObject);
                                newWebhookEventData.setActualInstance(deserialized);
                                return newWebhookEventData;
                            case "MPCVaultEventData":
                                deserialized = adapterMPCVaultEventData.fromJsonTree(jsonObject);
                                newWebhookEventData.setActualInstance(deserialized);
                                return newWebhookEventData;
                            case "PaymentAddressUpdateEventData":
                                deserialized = adapterPaymentAddressUpdateEventData.fromJsonTree(jsonObject);
                                newWebhookEventData.setActualInstance(deserialized);
                                return newWebhookEventData;
                            case "PaymentOrderEventData":
                                deserialized = adapterPaymentOrderEventData.fromJsonTree(jsonObject);
                                newWebhookEventData.setActualInstance(deserialized);
                                return newWebhookEventData;
                            case "PaymentRefundEventData":
                                deserialized = adapterPaymentRefundEventData.fromJsonTree(jsonObject);
                                newWebhookEventData.setActualInstance(deserialized);
                                return newWebhookEventData;
                            case "PaymentSettlementEvent":
                                deserialized = adapterPaymentSettlementEvent.fromJsonTree(jsonObject);
                                newWebhookEventData.setActualInstance(deserialized);
                                return newWebhookEventData;
                            case "PaymentTransactionEventData":
                                deserialized = adapterPaymentTransactionEventData.fromJsonTree(jsonObject);
                                newWebhookEventData.setActualInstance(deserialized);
                                return newWebhookEventData;
                            case "SuspendedTokenEventData":
                                deserialized = adapterSuspendedTokenEventData.fromJsonTree(jsonObject);
                                newWebhookEventData.setActualInstance(deserialized);
                                return newWebhookEventData;
                            case "TSSRequestWebhookEventData":
                                deserialized = adapterTSSRequestWebhookEventData.fromJsonTree(jsonObject);
                                newWebhookEventData.setActualInstance(deserialized);
                                return newWebhookEventData;
                            case "TokenListingEventData":
                                deserialized = adapterTokenListingEventData.fromJsonTree(jsonObject);
                                newWebhookEventData.setActualInstance(deserialized);
                                return newWebhookEventData;
                            case "TokensEventData":
                                deserialized = adapterTokensEventData.fromJsonTree(jsonObject);
                                newWebhookEventData.setActualInstance(deserialized);
                                return newWebhookEventData;
                            case "TransactionWebhookEventData":
                                deserialized = adapterTransactionWebhookEventData.fromJsonTree(jsonObject);
                                newWebhookEventData.setActualInstance(deserialized);
                                return newWebhookEventData;
                            case "WalletInfoEventData":
                                deserialized = adapterWalletInfoEventData.fromJsonTree(jsonObject);
                                newWebhookEventData.setActualInstance(deserialized);
                                return newWebhookEventData;
                            default:
                                log.log(Level.WARNING, String.format("Failed to lookup discriminator value `%s` for WebhookEventData. Possible values: Addresses BalanceUpdateInfo Chains MPCVault PaymentAddressUpdate PaymentOrder PaymentRefund PaymentSettlement PaymentTransaction SuspendedToken TSSRequest TokenListing Tokens Transaction WalletInfo AddressesEventData BalanceUpdateInfoEventData ChainsEventData MPCVaultEventData PaymentAddressUpdateEventData PaymentOrderEventData PaymentRefundEventData PaymentSettlementEvent PaymentTransactionEventData SuspendedTokenEventData TSSRequestWebhookEventData TokenListingEventData TokensEventData TransactionWebhookEventData WalletInfoEventData", jsonObject.get("data_type").getAsString()));
                        }
                    }

                    int match = 0;
                    ArrayList<String> errorMessages = new ArrayList<>();
                    TypeAdapter actualAdapter = elementAdapter;

                    // deserialize TransactionWebhookEventData
                    try {
                        // validate the JSON object to see if any exception is thrown
                        TransactionWebhookEventData.validateJsonElement(jsonElement);
                        actualAdapter = adapterTransactionWebhookEventData;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'TransactionWebhookEventData'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for TransactionWebhookEventData failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'TransactionWebhookEventData'", e);
                    }
                    // deserialize TSSRequestWebhookEventData
                    try {
                        // validate the JSON object to see if any exception is thrown
                        TSSRequestWebhookEventData.validateJsonElement(jsonElement);
                        actualAdapter = adapterTSSRequestWebhookEventData;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'TSSRequestWebhookEventData'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for TSSRequestWebhookEventData failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'TSSRequestWebhookEventData'", e);
                    }
                    // deserialize AddressesEventData
                    try {
                        // validate the JSON object to see if any exception is thrown
                        AddressesEventData.validateJsonElement(jsonElement);
                        actualAdapter = adapterAddressesEventData;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'AddressesEventData'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for AddressesEventData failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'AddressesEventData'", e);
                    }
                    // deserialize WalletInfoEventData
                    try {
                        // validate the JSON object to see if any exception is thrown
                        WalletInfoEventData.validateJsonElement(jsonElement);
                        actualAdapter = adapterWalletInfoEventData;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'WalletInfoEventData'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for WalletInfoEventData failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'WalletInfoEventData'", e);
                    }
                    // deserialize MPCVaultEventData
                    try {
                        // validate the JSON object to see if any exception is thrown
                        MPCVaultEventData.validateJsonElement(jsonElement);
                        actualAdapter = adapterMPCVaultEventData;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'MPCVaultEventData'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for MPCVaultEventData failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'MPCVaultEventData'", e);
                    }
                    // deserialize ChainsEventData
                    try {
                        // validate the JSON object to see if any exception is thrown
                        ChainsEventData.validateJsonElement(jsonElement);
                        actualAdapter = adapterChainsEventData;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'ChainsEventData'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for ChainsEventData failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'ChainsEventData'", e);
                    }
                    // deserialize TokensEventData
                    try {
                        // validate the JSON object to see if any exception is thrown
                        TokensEventData.validateJsonElement(jsonElement);
                        actualAdapter = adapterTokensEventData;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'TokensEventData'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for TokensEventData failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'TokensEventData'", e);
                    }
                    // deserialize TokenListingEventData
                    try {
                        // validate the JSON object to see if any exception is thrown
                        TokenListingEventData.validateJsonElement(jsonElement);
                        actualAdapter = adapterTokenListingEventData;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'TokenListingEventData'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for TokenListingEventData failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'TokenListingEventData'", e);
                    }
                    // deserialize BalanceUpdateInfoEventData
                    try {
                        // validate the JSON object to see if any exception is thrown
                        BalanceUpdateInfoEventData.validateJsonElement(jsonElement);
                        actualAdapter = adapterBalanceUpdateInfoEventData;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'BalanceUpdateInfoEventData'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for BalanceUpdateInfoEventData failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'BalanceUpdateInfoEventData'", e);
                    }
                    // deserialize SuspendedTokenEventData
                    try {
                        // validate the JSON object to see if any exception is thrown
                        SuspendedTokenEventData.validateJsonElement(jsonElement);
                        actualAdapter = adapterSuspendedTokenEventData;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'SuspendedTokenEventData'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for SuspendedTokenEventData failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'SuspendedTokenEventData'", e);
                    }
                    // deserialize PaymentOrderEventData
                    try {
                        // validate the JSON object to see if any exception is thrown
                        PaymentOrderEventData.validateJsonElement(jsonElement);
                        actualAdapter = adapterPaymentOrderEventData;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'PaymentOrderEventData'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for PaymentOrderEventData failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'PaymentOrderEventData'", e);
                    }
                    // deserialize PaymentRefundEventData
                    try {
                        // validate the JSON object to see if any exception is thrown
                        PaymentRefundEventData.validateJsonElement(jsonElement);
                        actualAdapter = adapterPaymentRefundEventData;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'PaymentRefundEventData'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for PaymentRefundEventData failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'PaymentRefundEventData'", e);
                    }
                    // deserialize PaymentSettlementEvent
                    try {
                        // validate the JSON object to see if any exception is thrown
                        PaymentSettlementEvent.validateJsonElement(jsonElement);
                        actualAdapter = adapterPaymentSettlementEvent;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'PaymentSettlementEvent'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for PaymentSettlementEvent failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'PaymentSettlementEvent'", e);
                    }
                    // deserialize PaymentTransactionEventData
                    try {
                        // validate the JSON object to see if any exception is thrown
                        PaymentTransactionEventData.validateJsonElement(jsonElement);
                        actualAdapter = adapterPaymentTransactionEventData;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'PaymentTransactionEventData'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for PaymentTransactionEventData failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'PaymentTransactionEventData'", e);
                    }
                    // deserialize PaymentAddressUpdateEventData
                    try {
                        // validate the JSON object to see if any exception is thrown
                        PaymentAddressUpdateEventData.validateJsonElement(jsonElement);
                        actualAdapter = adapterPaymentAddressUpdateEventData;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'PaymentAddressUpdateEventData'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for PaymentAddressUpdateEventData failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'PaymentAddressUpdateEventData'", e);
                    }

                    if (match == 1) {
                        WebhookEventData ret = new WebhookEventData();
                        ret.setActualInstance(actualAdapter.fromJsonTree(jsonElement));
                        return ret;
                    }

                    throw new IOException(String.format("Failed deserialization for WebhookEventData: %d classes match result, expected 1. Detailed failure message for oneOf schemas: %s. JSON: %s", match, errorMessages, jsonElement.toString()));
                }
            }.nullSafe();
        }
    }

    // store a list of schema names defined in oneOf
    public static final Map<String, Class<?>> schemas = new HashMap<String, Class<?>>();

    public WebhookEventData() {
        super("oneOf", Boolean.FALSE);
    }

    public WebhookEventData(AddressesEventData o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public WebhookEventData(BalanceUpdateInfoEventData o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public WebhookEventData(ChainsEventData o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public WebhookEventData(MPCVaultEventData o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public WebhookEventData(PaymentAddressUpdateEventData o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public WebhookEventData(PaymentOrderEventData o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public WebhookEventData(PaymentRefundEventData o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public WebhookEventData(PaymentSettlementEvent o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public WebhookEventData(PaymentTransactionEventData o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public WebhookEventData(SuspendedTokenEventData o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public WebhookEventData(TSSRequestWebhookEventData o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public WebhookEventData(TokenListingEventData o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public WebhookEventData(TokensEventData o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public WebhookEventData(TransactionWebhookEventData o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public WebhookEventData(WalletInfoEventData o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    static {
        schemas.put("TransactionWebhookEventData", TransactionWebhookEventData.class);
        schemas.put("TSSRequestWebhookEventData", TSSRequestWebhookEventData.class);
        schemas.put("AddressesEventData", AddressesEventData.class);
        schemas.put("WalletInfoEventData", WalletInfoEventData.class);
        schemas.put("MPCVaultEventData", MPCVaultEventData.class);
        schemas.put("ChainsEventData", ChainsEventData.class);
        schemas.put("TokensEventData", TokensEventData.class);
        schemas.put("TokenListingEventData", TokenListingEventData.class);
        schemas.put("BalanceUpdateInfoEventData", BalanceUpdateInfoEventData.class);
        schemas.put("SuspendedTokenEventData", SuspendedTokenEventData.class);
        schemas.put("PaymentOrderEventData", PaymentOrderEventData.class);
        schemas.put("PaymentRefundEventData", PaymentRefundEventData.class);
        schemas.put("PaymentSettlementEvent", PaymentSettlementEvent.class);
        schemas.put("PaymentTransactionEventData", PaymentTransactionEventData.class);
        schemas.put("PaymentAddressUpdateEventData", PaymentAddressUpdateEventData.class);
    }

    @Override
    public Map<String, Class<?>> getSchemas() {
        return WebhookEventData.schemas;
    }

    /**
     * Set the instance that matches the oneOf child schema, check
     * the instance parameter is valid against the oneOf child schemas:
     * AddressesEventData, BalanceUpdateInfoEventData, ChainsEventData, MPCVaultEventData, PaymentAddressUpdateEventData, PaymentOrderEventData, PaymentRefundEventData, PaymentSettlementEvent, PaymentTransactionEventData, SuspendedTokenEventData, TSSRequestWebhookEventData, TokenListingEventData, TokensEventData, TransactionWebhookEventData, WalletInfoEventData
     *
     * It could be an instance of the 'oneOf' schemas.
     */
    @Override
    public void setActualInstance(Object instance) {
        if (instance instanceof TransactionWebhookEventData) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof TSSRequestWebhookEventData) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof AddressesEventData) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof WalletInfoEventData) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof MPCVaultEventData) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof ChainsEventData) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof TokensEventData) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof TokenListingEventData) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof BalanceUpdateInfoEventData) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof SuspendedTokenEventData) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof PaymentOrderEventData) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof PaymentRefundEventData) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof PaymentSettlementEvent) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof PaymentTransactionEventData) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof PaymentAddressUpdateEventData) {
            super.setActualInstance(instance);
            return;
        }

        throw new RuntimeException("Invalid instance type. Must be AddressesEventData, BalanceUpdateInfoEventData, ChainsEventData, MPCVaultEventData, PaymentAddressUpdateEventData, PaymentOrderEventData, PaymentRefundEventData, PaymentSettlementEvent, PaymentTransactionEventData, SuspendedTokenEventData, TSSRequestWebhookEventData, TokenListingEventData, TokensEventData, TransactionWebhookEventData, WalletInfoEventData");
    }

    /**
     * Get the actual instance, which can be the following:
     * AddressesEventData, BalanceUpdateInfoEventData, ChainsEventData, MPCVaultEventData, PaymentAddressUpdateEventData, PaymentOrderEventData, PaymentRefundEventData, PaymentSettlementEvent, PaymentTransactionEventData, SuspendedTokenEventData, TSSRequestWebhookEventData, TokenListingEventData, TokensEventData, TransactionWebhookEventData, WalletInfoEventData
     *
     * @return The actual instance (AddressesEventData, BalanceUpdateInfoEventData, ChainsEventData, MPCVaultEventData, PaymentAddressUpdateEventData, PaymentOrderEventData, PaymentRefundEventData, PaymentSettlementEvent, PaymentTransactionEventData, SuspendedTokenEventData, TSSRequestWebhookEventData, TokenListingEventData, TokensEventData, TransactionWebhookEventData, WalletInfoEventData)
     */
    @SuppressWarnings("unchecked")
    @Override
    public Object getActualInstance() {
        return super.getActualInstance();
    }

    /**
     * Get the actual instance of `TransactionWebhookEventData`. If the actual instance is not `TransactionWebhookEventData`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `TransactionWebhookEventData`
     * @throws ClassCastException if the instance is not `TransactionWebhookEventData`
     */
    public TransactionWebhookEventData getTransactionWebhookEventData() throws ClassCastException {
        return (TransactionWebhookEventData)super.getActualInstance();
    }
    /**
     * Get the actual instance of `TSSRequestWebhookEventData`. If the actual instance is not `TSSRequestWebhookEventData`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `TSSRequestWebhookEventData`
     * @throws ClassCastException if the instance is not `TSSRequestWebhookEventData`
     */
    public TSSRequestWebhookEventData getTSSRequestWebhookEventData() throws ClassCastException {
        return (TSSRequestWebhookEventData)super.getActualInstance();
    }
    /**
     * Get the actual instance of `AddressesEventData`. If the actual instance is not `AddressesEventData`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `AddressesEventData`
     * @throws ClassCastException if the instance is not `AddressesEventData`
     */
    public AddressesEventData getAddressesEventData() throws ClassCastException {
        return (AddressesEventData)super.getActualInstance();
    }
    /**
     * Get the actual instance of `WalletInfoEventData`. If the actual instance is not `WalletInfoEventData`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `WalletInfoEventData`
     * @throws ClassCastException if the instance is not `WalletInfoEventData`
     */
    public WalletInfoEventData getWalletInfoEventData() throws ClassCastException {
        return (WalletInfoEventData)super.getActualInstance();
    }
    /**
     * Get the actual instance of `MPCVaultEventData`. If the actual instance is not `MPCVaultEventData`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `MPCVaultEventData`
     * @throws ClassCastException if the instance is not `MPCVaultEventData`
     */
    public MPCVaultEventData getMPCVaultEventData() throws ClassCastException {
        return (MPCVaultEventData)super.getActualInstance();
    }
    /**
     * Get the actual instance of `ChainsEventData`. If the actual instance is not `ChainsEventData`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `ChainsEventData`
     * @throws ClassCastException if the instance is not `ChainsEventData`
     */
    public ChainsEventData getChainsEventData() throws ClassCastException {
        return (ChainsEventData)super.getActualInstance();
    }
    /**
     * Get the actual instance of `TokensEventData`. If the actual instance is not `TokensEventData`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `TokensEventData`
     * @throws ClassCastException if the instance is not `TokensEventData`
     */
    public TokensEventData getTokensEventData() throws ClassCastException {
        return (TokensEventData)super.getActualInstance();
    }
    /**
     * Get the actual instance of `TokenListingEventData`. If the actual instance is not `TokenListingEventData`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `TokenListingEventData`
     * @throws ClassCastException if the instance is not `TokenListingEventData`
     */
    public TokenListingEventData getTokenListingEventData() throws ClassCastException {
        return (TokenListingEventData)super.getActualInstance();
    }
    /**
     * Get the actual instance of `BalanceUpdateInfoEventData`. If the actual instance is not `BalanceUpdateInfoEventData`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `BalanceUpdateInfoEventData`
     * @throws ClassCastException if the instance is not `BalanceUpdateInfoEventData`
     */
    public BalanceUpdateInfoEventData getBalanceUpdateInfoEventData() throws ClassCastException {
        return (BalanceUpdateInfoEventData)super.getActualInstance();
    }
    /**
     * Get the actual instance of `SuspendedTokenEventData`. If the actual instance is not `SuspendedTokenEventData`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `SuspendedTokenEventData`
     * @throws ClassCastException if the instance is not `SuspendedTokenEventData`
     */
    public SuspendedTokenEventData getSuspendedTokenEventData() throws ClassCastException {
        return (SuspendedTokenEventData)super.getActualInstance();
    }
    /**
     * Get the actual instance of `PaymentOrderEventData`. If the actual instance is not `PaymentOrderEventData`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `PaymentOrderEventData`
     * @throws ClassCastException if the instance is not `PaymentOrderEventData`
     */
    public PaymentOrderEventData getPaymentOrderEventData() throws ClassCastException {
        return (PaymentOrderEventData)super.getActualInstance();
    }
    /**
     * Get the actual instance of `PaymentRefundEventData`. If the actual instance is not `PaymentRefundEventData`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `PaymentRefundEventData`
     * @throws ClassCastException if the instance is not `PaymentRefundEventData`
     */
    public PaymentRefundEventData getPaymentRefundEventData() throws ClassCastException {
        return (PaymentRefundEventData)super.getActualInstance();
    }
    /**
     * Get the actual instance of `PaymentSettlementEvent`. If the actual instance is not `PaymentSettlementEvent`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `PaymentSettlementEvent`
     * @throws ClassCastException if the instance is not `PaymentSettlementEvent`
     */
    public PaymentSettlementEvent getPaymentSettlementEvent() throws ClassCastException {
        return (PaymentSettlementEvent)super.getActualInstance();
    }
    /**
     * Get the actual instance of `PaymentTransactionEventData`. If the actual instance is not `PaymentTransactionEventData`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `PaymentTransactionEventData`
     * @throws ClassCastException if the instance is not `PaymentTransactionEventData`
     */
    public PaymentTransactionEventData getPaymentTransactionEventData() throws ClassCastException {
        return (PaymentTransactionEventData)super.getActualInstance();
    }
    /**
     * Get the actual instance of `PaymentAddressUpdateEventData`. If the actual instance is not `PaymentAddressUpdateEventData`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `PaymentAddressUpdateEventData`
     * @throws ClassCastException if the instance is not `PaymentAddressUpdateEventData`
     */
    public PaymentAddressUpdateEventData getPaymentAddressUpdateEventData() throws ClassCastException {
        return (PaymentAddressUpdateEventData)super.getActualInstance();
    }

    /**
     * Validates the JSON Element and throws an exception if issues found
     *
     * @param jsonElement JSON Element
     * @throws IOException if the JSON Element is invalid with respect to WebhookEventData
     */
    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
        // validate oneOf schemas one by one
        int validCount = 0;
        ArrayList<String> errorMessages = new ArrayList<>();
        // validate the json string with TransactionWebhookEventData
        try {
            TransactionWebhookEventData.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for TransactionWebhookEventData failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with TSSRequestWebhookEventData
        try {
            TSSRequestWebhookEventData.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for TSSRequestWebhookEventData failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with AddressesEventData
        try {
            AddressesEventData.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for AddressesEventData failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with WalletInfoEventData
        try {
            WalletInfoEventData.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for WalletInfoEventData failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with MPCVaultEventData
        try {
            MPCVaultEventData.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for MPCVaultEventData failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with ChainsEventData
        try {
            ChainsEventData.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for ChainsEventData failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with TokensEventData
        try {
            TokensEventData.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for TokensEventData failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with TokenListingEventData
        try {
            TokenListingEventData.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for TokenListingEventData failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with BalanceUpdateInfoEventData
        try {
            BalanceUpdateInfoEventData.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for BalanceUpdateInfoEventData failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with SuspendedTokenEventData
        try {
            SuspendedTokenEventData.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for SuspendedTokenEventData failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with PaymentOrderEventData
        try {
            PaymentOrderEventData.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for PaymentOrderEventData failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with PaymentRefundEventData
        try {
            PaymentRefundEventData.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for PaymentRefundEventData failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with PaymentSettlementEvent
        try {
            PaymentSettlementEvent.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for PaymentSettlementEvent failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with PaymentTransactionEventData
        try {
            PaymentTransactionEventData.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for PaymentTransactionEventData failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with PaymentAddressUpdateEventData
        try {
            PaymentAddressUpdateEventData.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for PaymentAddressUpdateEventData failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        if (validCount != 1) {
            // throw new IOException(String.format("The JSON string is invalid for WebhookEventData with oneOf schemas: AddressesEventData, BalanceUpdateInfoEventData, ChainsEventData, MPCVaultEventData, PaymentAddressUpdateEventData, PaymentOrderEventData, PaymentRefundEventData, PaymentSettlementEvent, PaymentTransactionEventData, SuspendedTokenEventData, TSSRequestWebhookEventData, TokenListingEventData, TokensEventData, TransactionWebhookEventData, WalletInfoEventData. %d class(es) match the result, expected 1. Detailed failure message for oneOf schemas: %s. JSON: %s", validCount, errorMessages, jsonElement.toString()));
        }
    }

    /**
     * Create an instance of WebhookEventData given an JSON string
     *
     * @param jsonString JSON string
     * @return An instance of WebhookEventData
     * @throws IOException if the JSON string is invalid with respect to WebhookEventData
     */
    public static WebhookEventData fromJson(String jsonString) throws IOException {
        return JSON.getGson().fromJson(jsonString, WebhookEventData.class);
    }

    /**
     * Convert an instance of WebhookEventData to an JSON string
     *
     * @return JSON string
     */
    public String toJson() {
        return JSON.getGson().toJson(this);
    }
}

